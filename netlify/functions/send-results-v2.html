const nodemailer = require('nodemailer');
const fetch = require('node-fetch');

/**
 * Calls the Gemini API to get personalized feedback on incorrect answers.
 * @param {Array} incorrectAnswersData Array of objects with incorrect answers.
 * @param {string} apiKey The Gemini API key.
 * @returns {Promise<string|null>} The AI-generated feedback text or null.
 */
async function getAIFeedback(incorrectAnswersData, apiKey) {
  if (!apiKey) {
    console.log("GEMINI_API_KEY is not set. Skipping AI feedback.");
    return null;
  }
  if (!incorrectAnswersData || incorrectAnswersData.length === 0) {
    return null; // No incorrect answers to analyze.
  }

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

  const systemPrompt = `Vous √™tes un professeur de cor√©en sympathique et encourageant pour des d√©butants francophones.
Analysez les erreurs suivantes de l'√©tudiant sur les particules cor√©ennes ÏùÄ/Îäî, Ïù¥/Í∞Ä, ÏùÑ/Î•º.
Identifiez la principale faiblesse ou le point de confusion de l'√©tudiant (par ex: confusion entre contraste et sujet, ou erreur de Î∞õÏπ®).
Fournissez une explication concise (3-4 phrases max) et simple en fran√ßais, suivie de la m√™me explication en cor√©en.
Utilisez un langage tr√®s simple et des exemples clairs pour aider l'√©tudiant √† comprendre la nuance.
Commencez par une analyse g√©n√©rale ("On dirait que tu confonds parfois..."), puis donnez un ou deux exemples corrig√©s tir√©s des erreurs de l'√©tudiant.
Soyez positif et encourageant. Adressez-vous directement √† l'√©tudiant.`;

  const userQuery = `Voici les erreurs de l'√©tudiant. L'objectif est de comprendre si l'√©tudiant a du mal avec la r√®gle du Î∞õÏπ® (consonne finale), ou s'il confond le r√¥le de ÏùÄ/Îäî (contraste) avec Ïù¥/Í∞Ä (identification du sujet) ou ÏùÑ/Î•º (objet). Analysez ses r√©ponses et donnez une explication personnalis√©e :\n\n${JSON.stringify(incorrectAnswersData, null, 2)}`;
  
  const payload = {
      contents: [{ parts: [{ text: userQuery }] }],
      systemInstruction: { parts: [{ text: systemPrompt }] },
  };

  try {
      const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
      });
      if (!response.ok) {
          const errorBody = await response.text();
          console.error(`Gemini API request failed with status ${response.status}:`, errorBody);
          return null; // Return null on failure
      }
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text || null;
  } catch (error) {
      console.error("Error fetching AI feedback:", error);
      return null; // Return null on failure
  }
}


/**
 * Helper function to safely escape HTML entities.
 */
function escapeHtml(str = '') {
  if (typeof str !== 'string') return '';
  return str.replace(/[&<>"']/g, (s) => ({
    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;',
  }[s]));
}

/**
 * Helper function to format the user's answer.
 */
function formatUserAnswer(q) {
  const userAnswer = q.userAnswer || {};
  if (Object.keys(userAnswer).length === 0) return '<i>(vide)</i>';
 
  if (typeof userAnswer === 'object' && userAnswer !== null) {
      return Object.entries(userAnswer)
          .map(([key, value]) => `<b>${key}:</b> ${escapeHtml(value || '')}`)
          .join('<br>');
  }
  return escapeHtml(userAnswer);
}

exports.handler = async (event) => {
  try {
    if (event.httpMethod !== 'POST') {
      return { statusCode: 405, body: 'Method Not Allowed' };
    }

    const { GMAIL_USER, GMAIL_APP_PASSWORD, RECIPIENT_EMAIL, GEMINI_API_KEY } = process.env;
    if (!GMAIL_USER || !GMAIL_APP_PASSWORD || !RECIPIENT_EMAIL) {
      return { statusCode: 500, body: JSON.stringify({ message: 'Missing env vars for Gmail' }) };
    }

    const payload = JSON.parse(event.body || '{}');
    const {
      studentName = '√âl√®ve',
      startTime,
      endTime,
      totalTimeSeconds = 0,
      questions = [],
      incorrectAnswers = [],
    } = payload;

    // AI Feedback is generated first.
    const aiFeedback = await getAIFeedback(incorrectAnswers, GEMINI_API_KEY);

    // After getting feedback, send the email asynchronously (don't wait for it)
    sendEmailWithFeedback(payload, aiFeedback);
    
    // Return the feedback to the student immediately.
    return { 
        statusCode: 200, 
        body: JSON.stringify({ 
            message: 'OK',
            aiFeedback: aiFeedback 
        }) 
    };

  } catch (err) {
    console.error('Error in main handler function:', err);
    return { statusCode: 500, body: JSON.stringify({ message: err.message }) };
  }
};


// This function sends the email but doesn't need to be awaited by the main handler.
async function sendEmailWithFeedback(payload, aiFeedback) {
    try {
        const { GMAIL_USER, GMAIL_APP_PASSWORD, RECIPIENT_EMAIL } = process.env;
        const { studentName, startTime, endTime, totalTimeSeconds, questions } = payload;

        const attachments = questions.flatMap((q) => {
          if (q?.recording?.base64) {
            return [{
              filename: `rec_q${q.number}_${studentName.replace(/\s/g, '_')}.webm`,
              content: Buffer.from(q.recording.base64, 'base64'),
              contentType: 'audio/webm',
            }];
          }
          return [];
        });

        const gradableQuestions = questions.filter(q => q.type !== 'explanation');
        const correctCount = gradableQuestions.filter(q => q.isCorrect).length;
        const totalGraded = gradableQuestions.length;
        const score = totalGraded > 0 ? Math.round((correctCount / totalGraded) * 100) : 0;
        
        const mins = Math.floor(totalTimeSeconds / 60);
        const secs = Math.round(totalTimeSeconds % 60);

        const rowHtml = gradableQuestions.map((q) => {
            const answered = formatUserAnswer(q);
            const ok = q.isCorrect ? '‚úîÔ∏è' : '‚ùå';
            const audioHtml = q?.recording?.base64 ? `<div style="margin-top:6px; font-size:12px; color:#666;">* Fichier audio joint</div>` : '';

            return `
              <tr>
                <td style="border:1px solid #eee;padding:6px;text-align:center">${q.number ?? ''}</td>
                <td style="border:1px solid #eee;padding:6px">${escapeHtml(q.fr || '')}</td>
                <td style="border:1px solid #eee;padding:6px">${escapeHtml(q.ko || '')}</td>
                <td style="border:1px solid #eee;padding:6px">${answered} ${audioHtml}</td>
                <td style="border:1px solid #eee;padding:6px;text-align:center">${ok}</td>
                <td style="border:1px solid #eee;padding:6px;text-align:center">${q.listenCount || 0}</td>
                <td style="border:1px solid #eee;padding:6px;text-align:center">${q.hint1Count || 0}</td>
                <td style="border:1px solid #eee;padding:6px;text-align:center">${q.hint2Count || 0}</td>
              </tr>`;
          }).join('');
          
        const aiFeedbackHtml = aiFeedback ? `
          <div style="background:#e0e7ff; border-left: 5px solid #4f46e5; padding:15px; border-radius:8px; margin:25px 0;">
              <h3 style="margin:0 0 10px 0; font-size:20px; color:#3730a3;">üí° Analyse et conseils de l'IA</h3>
              <p style="margin:0; font-size:16px; color:#333; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(aiFeedback).replace(/\n/g, '<br>')}</p>
          </div>
        ` : '';

        const html = `
          <div style="font-family:Arial, sans-serif; color:#333;">
            <h2>R√©sultats du test de cor√©en (v2)</h2>
            <p><b>√âl√®ve:</b> ${escapeHtml(studentName)}</p>
            <div style="background:#f0f4f8; padding:15px; border-radius:8px; margin:15px 0; text-align:center;">
              <h3 style="margin:0; font-size:24px;">Score Final: ${score} / 100</h3>
              <p style="margin:5px 0 0; font-size:16px; color:#555;">(${correctCount} / ${totalGraded} bonnes r√©ponses)</p>
            </div>
            ${aiFeedbackHtml}
            <p><b>D√©but:</b> ${escapeHtml(String(startTime || ''))}<br/>
               <b>Fin:</b> ${escapeHtml(String(endTime || ''))}<br/>
               <b>Temps total:</b> ${mins}m ${secs}s</p>
            <table style="border-collapse:collapse;width:100%;font-size:14px">
              <thead>
                <tr style="background:#f0f4f8">
                  <th style="border:1px solid #eee;padding:6px">#</th><th style="border:1px solid #eee;padding:6px">Fran√ßais</th><th style="border:1px solid #eee;padding:6px">Cor√©en</th>
                  <th style="border:1px solid #eee;padding:6px">R√©ponse √©l√®ve</th><th style="border:1px solid #eee;padding:6px">OK?</th>
                  <th style="border:1px solid #eee;padding:6px">√âcoutes</th><th style="border:1px solid #eee;padding:6px">Indice 1</th><th style="border:1px solid #eee;padding:6px">Indice 2</th>
                </tr>
              </thead>
              <tbody>${rowHtml}</tbody>
            </table>
          </div>`;

        const transporter = nodemailer.createTransport({
          host: 'smtp.gmail.com', port: 465, secure: true,
          auth: { user: GMAIL_USER, pass: GMAIL_APP_PASSWORD },
        });

        await transporter.sendMail({
          from: `Korean Pondang <${GMAIL_USER}>`, to: RECIPIENT_EMAIL,
          subject: `R√©sultats v2 ‚Äì ${studentName} ‚Äì Score: ${score}/100`,
          html, attachments,
        });

        console.log('Email sent successfully.');
    } catch (err) {
        console.error('Error in sendEmailWithFeedback function:', err);
    }
}

