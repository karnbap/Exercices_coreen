<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>한국어 연습: 후에 / 전에</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    body { font-family: 'Inter','Pretendard',sans-serif; background:#f8fafc; }
    .made-by-top,.made-by-bottom{ text-align:center; padding:8px; font-size:.85rem; color:#475569; background:#f1f5f9 }
    .made-by-top{ border-bottom:1px solid #e2e8f0 }
    .made-by-bottom{ border-top:1px solid #e2e8f0; margin-top:40px }
    .print-button-container{ display:flex; justify-content:flex-end; margin-bottom:20px }
    .btn{ display:inline-flex; align-items:center; justify-content:center; font-weight:700; border-radius:.75rem; transition:.2s; cursor:pointer; padding:.75rem 1.25rem }
    .btn:disabled{ background:#d1d5db; cursor:not-allowed }
    .btn-primary{ background:#4f46e5; color:#fff }
    .btn-primary:hover:not(:disabled){ background:#3730a3 }
    .btn-secondary{ background:#e0e7ff; color:#3730a3; padding:.5rem 1rem }
    .btn-secondary:hover:not(:disabled){ background:#c7d2fe }
    .btn-choice{ border:2px solid #e5e7eb; width:100%; justify-content:flex-start; text-align:left; padding:1rem; font-size:1.05rem }
    .btn-choice:hover{ border-color:#facc15; background:#fef9c3 }
    .btn-choice.selected{ border-color:#fbbf24; background:#fef08a }
    .btn-hint{ padding:.5rem 1rem; font-size:.9rem }
    .btn-record{ background:#ef4444; color:#fff }
    .btn-record.recording{ background:#10b981 }
    .invisible{ visibility:hidden }
    .section-title{ font-size:1.35rem; font-weight:800; color:#1e293b; border-bottom:2px solid #cbd5e1; padding-bottom:.4rem; margin-bottom:1rem }
    @media print{ .no-print{ display:none !important } main{ box-shadow:none !important; padding:0 !important } }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">

  <!-- 상단 제작자/팀/메일 -->
  <div class="made-by-top no-print">
    made by <b>성일, Pondant</b> · <a href="mailto:Lapeace29@gmail.com" class="underline">Lapeace29@gmail.com</a>
  </div>

  <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
    <header class="text-center mb-8">
      <h1 class="text-3xl sm:text-4xl font-extrabold text-slate-900">Exercice Coréen : Après / Avant</h1>
      <p class="text-md text-slate-600 mt-2">N + 후에 / R+(으)ㄴ 후에 / R+기 전에</p>
    </header>

    <!-- 상단 프린트 버튼 -->
    <div class="print-button-container no-print">
      <button onclick="window.print()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 2a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V4a2 2 0 00-2-2H5zm0 2h10v2H5V4zm2 5h6v1H7V9zm0 2h6v1H7v-1z" clip-rule="evenodd"/></svg>
        Imprimer / 프린트
      </button>
    </div>

    <!-- 시작 화면 -->
    <div id="start-screen" class="text-center">
      <input type="text" id="student-name"
             class="w-full max-w-sm p-3 border-2 border-slate-300 rounded-lg text-center text-lg focus:border-purple-500 focus:ring focus:ring-purple-200 transition"
             placeholder="학생 이름이 궁금해요! (Ton nom)">
      <button id="start-btn"
              class="mt-4 w-full max-w-sm bg-purple-600 hover:bg-purple-800 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg transform hover:scale-105 transition">
        시작! (Commencer)
      </button>
    </div>

    <!-- 문제 컨테이너 -->
    <main id="quiz-container" class="hidden"></main>

    <!-- 결과 화면 -->
    <div id="result-screen" class="hidden text-center p-8 bg-white rounded-2xl shadow-xl max-w-2xl mx-auto no-print">
      <h2 class="text-3xl font-bold mb-4">🎉 Bravo ! 🎉</h2>
      <p id="result-message" class="text-lg text-slate-700 mb-6"></p>

      <div class="flex justify-center space-x-3 mt-8">
        <a href="/index.html" class="btn btn-secondary">이전 연습으로 가기 / Aller à l’exercice précédent</a>
        <button id="retry-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg">
          다시하기 (Recommencer)
        </button>
      </div>
    </div>
  </div>

  <!-- 하단 제작자/팀/메일 -->
  <div class="made-by-bottom no-print">
    made by <b>성일, Pondant</b> · <a href="mailto:Lapeace29@gmail.com" class="underline">Lapeace29@gmail.com</a>
  </div>

  <script>
    // ===== 공통 유틸 =====
    function base64ToBlob(base64, mimeType) {
      const byteChars = atob(base64);
      const len = byteChars.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = byteChars.charCodeAt(i);
      return new Blob([bytes], { type: mimeType || 'audio/mpeg' });
    }
    const $ = (sel) => document.querySelector(sel);

    // ===== 상태 =====
    const startScreen = $('#start-screen');
    const quizContainer = $('#quiz-container');
    const resultScreen = $('#result-screen');
    const startBtn = $('#start-btn');
    const studentNameInput = $('#student-name');
    const retryBtn = $('#retry-btn');

    studentNameInput.placeholder = ["Julien", "Léa", "Léo", "Alice", "Emma", "Lucas"][Math.floor(Math.random()*6)];

    let studentName = '', startTime, endTime;
    let currentQuestionIndex = 0;
    let questionsData = [], quizData = [];
    let mediaRecorder, audioChunks = [];
    let resultsSent = false; // 중복 전송 방지

    // ===== 데이터 =====
    const verbPairs = [
      { base:'밥을 먹다', verb:'manger', afterForm:'먹은 후에', beforeForm:'먹기 전에' },
      { base:'숙제를 하다', verb:'faire les devoirs', afterForm:'한 후에', beforeForm:'하기 전에' },
      { base:'영화를 보다', verb:'regarder un film', afterForm:'본 후에', beforeForm:'보기 전에' },
      { base:'책을 읽다', verb:'lire un livre', afterForm:'읽은 후에', beforeForm:'읽기 전에' },
      { base:'운동을 하다', verb:'faire du sport', afterForm:'운동한 후에', beforeForm:'운동하기 전에' },
      { base:'잠을 자다', verb:'dormir', afterForm:'잔 후에', beforeForm:'자기 전에' },
      { base:'수업에 들어가다', verb:'entrer en classe', afterForm:'들어간 후에', beforeForm:'들어가기 전에' },
      { base:'손을 씻다', verb:'se laver les mains', afterForm:'씻은 후에', beforeForm:'씻기 전에' },
      { base:'밖으로 나가다', verb:'sortir', afterForm:'나간 후에', beforeForm:'나가기 전에' },
      { base:'커피를 마시다', verb:'boire du café', afterForm:'마신 후에', beforeForm:'마시기 전에' }
    ];
    const sentencePool = [
      { fr:"Après avoir fini le travail, je suis rentré chez moi.", ko:"일을 끝낸 후에 집에 돌아왔어요.", hint1:"ㅇㅇ ㄲㄴ ㅎㅇ ㅈㅇ ㄷㅇㅇㅇㅇ.", hint2:"일(travail), 끝내다(finir), 집(maison)"},
      { fr:"Avant de sortir, j’ai pris mon parapluie.", ko:"나가기 전에 우산을 챙겼어요.", hint1:"ㄴㄱㄱ ㅈㅇ ㅇㅅㅇ ㅊㄱㅇㅇ.", hint2:"나가다(sortir), 우산(parapluie), 챙기다(prendre)"},
      { fr:"Après avoir regardé le film, j’ai dormi.", ko:"영화를 본 후에 잠을 잤어요.", hint1:"ㅇㅎㄹ ㅂ ㅎㅇ ㅈㅇ ㅈㅇㅇ.", hint2:"영화(film), 보다(regarder), 잠을 자다(dormir)"},
      { fr:"Avant de manger du pain, je bois du lait.", ko:"빵을 먹기 전에 우유를 마셔요.", hint1:"ㅃㅇ ㅁㄱ ㅈㅇ ㅇㅇㄹ ㅁㅅㅇ.", hint2:"빵(pain), 먹다(manger), 우유(lait), 마시다(boire)"},
      { fr:"Après avoir fait du sport, j'ai pris une douche.", ko:"운동한 후에 샤워했어요.", hint1:"ㅇㄷㅎ ㅎㅇ ㅅㅇㅎㅇㅇ.", hint2:"운동하다(faire du sport), 샤워하다(prendre une douche)"},
      { fr:"Avant de dormir, je lis un livre.", ko:"자기 전에 책을 읽어요.", hint1:"ㅈㄱ ㅈㅇ ㅊㅇ ㅇㅇㅇ.", hint2:"자다(dormir), 책(livre), 읽다(lire)"}
    ];
    const shuffle = (arr)=>arr.sort(()=>Math.random()-0.5);

    function getGradingMessage(p, lang='ko'){
      if(lang==='fr'){
        if(p>=100) return "Parfait absolu ! 👑🎉 Génie confirmé !";
        if(p>=80)  return "Très bien joué ! 👍 Presque un maître !";
        if(p>=60)  return "Pas mal du tout ! 😎 Encore un petit effort et c’est le top !";
        return "Allez, un petit café et on repart ! ☕💪";
      }
      if(p>=100) return "완벽 그 자체! 👑🎉 천재 인증!";
      if(p>=80)  return "아주 잘했어요! 👍 거의 마스터!";
      if(p>=60)  return "꽤 잘했어요! 😎 조금만 더!";
      return "자, 커피 한 잔 하고 다시! ☕💪🇰🇷";
    }

    // ===== 퀴즈 구성 =====
    function generateAndSetQuizData() {
      quizData = [];
      quizData.push({ type:'explanation' });

      const vp = shuffle([...verbPairs]);

      // 쉬운 선택형 5
      vp.slice(0,5).forEach(pair=>{
        const useAfter = Math.random()>0.5;
        const correct = useAfter ? pair.afterForm : pair.beforeForm;
        const distract = useAfter ? pair.beforeForm : pair.afterForm;
        const fr_instruction = useAfter ? `après avoir ${pair.verb}` : `avant de ${pair.verb}`;
        quizData.push({
          type:'multiple-choice',
          fr:`Choisissez la forme correcte pour dire "${fr_instruction}".`,
          ko:`(${pair.base}) 친구를 만나요.`,
          correctAnswer: correct,
          choices: shuffle([correct, distract])
        });
      });

      // 빈칸 5
      vp.slice(5,10).forEach(pair=>{
        const useAfter = Math.random()>0.5;
        const correct = useAfter ? pair.afterForm : pair.beforeForm;
        const fr_instruction = useAfter ? `après avoir ${pair.verb}` : `avant de ${pair.verb}`;
        quizData.push({
          type:'fill-in-the-blank',
          fr:`Écrivez la forme pour dire "${fr_instruction}".`,
          ko:`(${pair.base}) ___ 친구를 만나요.`,
          correctAnswer: correct
        });
      });

      // 번역 5
      shuffle([...sentencePool]).slice(0,5).forEach(q=>quizData.push({ type:'translate-sentence', ...q }));
      // 듣기 5
      shuffle([...sentencePool]).slice(0,5).forEach(q=>quizData.push({ type:'listening-dictation', ...q }));
    }

    // ===== 이벤트 =====
    startBtn.addEventListener('click', startQuiz);
    retryBtn.addEventListener('click', () => location.reload());

    function startQuiz(){
      studentName = studentNameInput.value.trim();
      if(!studentName){ alert('학생 이름을 입력해주세요! (Veuillez entrer votre nom)'); return; }
      startTime = new Date();
      startScreen.classList.add('hidden');
      quizContainer.classList.remove('hidden');
      generateAndSetQuizData();
      questionsData = quizData.map((q,i)=>({
        number:i,
        ...q,
        userAnswer:{},
        listenCount:0,
        hint1Count:0,
        hint2Count:0,
        recording:{}
      }));
      renderQuestion();
    }

    function renderQuestion(){
      quizContainer.innerHTML = '';
      if(currentQuestionIndex >= quizData.length){ finishQuiz(); return; }
      const q = quizData[currentQuestionIndex];

      const card = document.createElement('div');
      card.className = 'p-6 bg-white rounded-xl shadow-lg';

      let html = `<p class="text-sm text-slate-500 mb-4">Question ${currentQuestionIndex} / ${quizData.length-1}</p>`;

      if(q.type==='explanation'){
        html += `
          <h2 class="section-title">Comment dire "Après" et "Avant" en coréen?</h2>
          <div class="space-y-6 text-lg">
            <div>
              <h3 class="font-bold text-xl mb-2 text-indigo-700">1. Avec un Verbe (동사)</h3>
              <div class="pl-4 border-l-4 border-indigo-200 space-y-4">
                <div>
                  <p><strong>Pour dire "après avoir fait..." → <code class="bg-indigo-100 p-1 rounded">-(으)ㄴ 후에</code></strong></p>
                  <p class="ml-4">Ex) <strong>먹다</strong> → <strong>먹<span class="text-red-500 font-semibold">은 후에</span></strong></p>
                  <p class="ml-4">Ex) <strong>가다</strong> → <strong>가<span class="text-red-500 font-semibold">ㄴ 후에</span></strong></p>
                </div>
                <div>
                  <p><strong>Pour dire "avant de faire..." → <code class="bg-green-100 p-1 rounded">-기 전에</code></strong></p>
                  <p class="ml-4">Ex) <strong>먹다</strong> → <strong>먹<span class="text-red-500 font-semibold">기 전에</span></strong></p>
                  <p class="ml-4">Ex) <strong>가다</strong> → <strong>가<span class="text-red-500 font-semibold">기 전에</span></strong></p>
                </div>
              </div>
            </div>
            <div class="border-t pt-6">
              <h3 class="font-bold text-xl mb-2 text-sky-700">2. Avec un Nom (명사)</h3>
              <div class="pl-4 border-l-4 border-sky-200 space-y-2">
                <p>On peut aussi les utiliser avec des noms décrivant <strong>une action/événement</strong>.</p>
                <p class="ml-4"><strong>수업 후에</strong> (après le cours) / <strong>식사 전에</strong> (avant le repas)</p>
                <div class="mt-4 p-3 bg-amber-50 border-l-4 border-amber-400 rounded-r-lg">
                  <p class="font-bold text-amber-800">💡 Astuce !</p>
                  <p class="text-amber-700">"일 후에" 보다는 <strong>"퇴근 후에"</strong>가 더 자연스러워요.</p>
                </div>
              </div>
            </div>
          </div>`;
      } else {
        if(q.type==='multiple-choice') html += `<h2 class="section-title">Étape 1: Choisir / 알맞은 답 고르기</h2>`;
        if(q.type==='fill-in-the-blank') html += `<h2 class="section-title">Étape 2: Remplir / 빈칸 채우기</h2>`;
        if(q.type==='translate-sentence') html += `<h2 class="section-title">Étape 3: Traduire / 문장 번역하기</h2>`;
        if(q.type==='listening-dictation') html += `<h2 class="section-title">Étape 4: Écouter et écrire / 듣고 받아쓰기</h2>`;

        if(q.type==='listening-dictation'){
          html += `<p class="text-xl font-semibold mb-2">Écoutez et écrivez. <span class="font-normal text-slate-600 ml-1">Mots-clés: ${q.hint2}</span></p>`;
        } else {
          html += `<p class="text-xl font-semibold text-slate-800 mb-2">${q.fr}</p>`;
        }

        if(q.type==='listening-dictation'){
          html += `<div class="flex items-center mt-2 mb-4">
            <button onclick="playAudio(event, '${q.ko.replace(/'/g,"\\'")}', 'man')" class="btn btn-secondary">Écouter / 문장 듣기</button>
          </div>`;
        } else if(q.type!=='translate-sentence'){
          html += `<p class="text-2xl font-bold text-indigo-600 mb-4">${q.ko}</p>`;
        }

        if(q.type==='multiple-choice'){
          html += `<div class="grid grid-cols-1 gap-3">${
            q.choices.map(c=>`<button class="btn btn-choice" data-answer="${c}">${c}</button>`).join('')
          }</div>`;
        } else if(q.type==='fill-in-the-blank'){
          html += q.ko.replace('___', `<input type="text" id="answer-input" class="p-2 border-2 border-slate-300 rounded-lg text-lg text-center mx-2" style="width:220px;">`);
          html += `<div class="mt-4 p-3 bg-slate-50 rounded-lg text-slate-600">
              <p class="font-bold">💡 Rappel (복습)</p>
              <p><b class="text-green-700">-기 전에</b> (avant de) : 동사 어간 + 기 전에<br>
                 <b class="text-indigo-700">-(으)ㄴ 후에</b> (après avoir) : -은 후에(자음), -ㄴ 후에(모음)</p>
            </div>`;
        } else if(q.type==='translate-sentence'){
          html += `<textarea id="answer-input" class="w-full p-3 border-2 border-slate-300 rounded-lg" rows="2" placeholder="Traduisez en coréen..."></textarea>`;
          if(q.hint1 && q.hint2){
            html += `<div class="mt-4 flex gap-2">
                <button onclick="showHint(1, '${q.hint1}')" class="btn-hint bg-green-100 text-green-800">Aidez moi 🙏 (초성)</button>
                <button onclick="showHint(2, '${q.hint2}')" class="btn-hint bg-blue-100 text-blue-800">Au secours 🛟 (단어)</button>
              </div>
              <div id="hint-display" class="mt-3 p-3 bg-slate-50 rounded-lg text-slate-600 min-h-[50px]"></div>`;
          }
        } else if(q.type==='listening-dictation'){
          html += `
            <p class="font-semibold mt-4 mb-2">1. 듣고 받아쓰기</p>
            <input id="dictation1" class="w-full p-2 border-2 border-slate-300 rounded-lg">
            <p class="font-semibold mt-4 mb-2">2. 내 목소리 녹음</p>
            <div class="flex items-center gap-4">
              <button id="record-btn" class="btn btn-record" onclick="toggleRecording()">Enregistrer / 녹음하기</button>
              <audio id="recording-player" controls hidden></audio>
            </div>
            <p class="font-semibold mt-4 mb-2">3. 내 목소리를 듣고 받아쓰기</p>
            <input id="dictation2" class="w-full p-2 border-2 border-slate-300 rounded-lg">`;
        }
      }

      // 하단 네비/끝내기
      html += `
        <div class="mt-6 flex justify-between items-center no-print">
          <button id="prev-btn" class="btn btn-primary ${currentQuestionIndex===0?'invisible':''}">Précédent / 이전</button>
          <button id="next-btn" class="btn btn-primary">
            ${currentQuestionIndex===quizData.length-1 ? 'Terminer / 끝내기' : 'Suivant / 다음'}
          </button>
        </div>`;

      card.innerHTML = html;
      quizContainer.appendChild(card);

      addQuestionListeners();
    }

    function addQuestionListeners(){
      $('#prev-btn')?.addEventListener('click', prevQuestion);
      $('#next-btn')?.addEventListener('click', nextQuestion);

      document.querySelectorAll('.btn-choice').forEach(btn=>{
        btn.addEventListener('click', (e)=>{
          document.querySelectorAll('.btn-choice').forEach(b=>b.classList.remove('selected'));
          e.currentTarget.classList.add('selected');
          setTimeout(nextQuestion, 250);
        });
      });
    }

    function showHint(num, text){
      if(num===1) questionsData[currentQuestionIndex].hint1Count++;
      else questionsData[currentQuestionIndex].hint2Count++;
      const hintBox = $('#hint-display');
      if(hintBox) hintBox.textContent = text;
    }

    function saveCurrentAnswer(){
      const q = quizData[currentQuestionIndex];
      const qd = questionsData[currentQuestionIndex];
      if(!q || !qd) return;

      if(q.type==='multiple-choice'){
        const sel = document.querySelector('.btn-choice.selected');
        qd.userAnswer = sel ? sel.dataset.answer : '';
      } else if(q.type==='fill-in-the-blank' || q.type==='translate-sentence'){
        qd.userAnswer = $('#answer-input')?.value.trim() || '';
      } else if(q.type==='listening-dictation'){
        qd.userAnswer = {
          dictation1: $('#dictation1')?.value.trim() || '',
          dictation2: $('#dictation2')?.value.trim() || ''
        };
      }
    }

    function prevQuestion(){ if(currentQuestionIndex>0){ saveCurrentAnswer(); currentQuestionIndex--; renderQuestion(); } }
    function nextQuestion(){
      saveCurrentAnswer();
      if(currentQuestionIndex < quizData.length - 1){ currentQuestionIndex++; renderQuestion(); }
      else { finishQuiz(); }
    }

    function evaluateAnswers(){
      questionsData.forEach(qd=>{
        if(qd.type==='explanation') return;
        const fmt = (s)=>(s||'').replace(/[.\s+!?]/g,'').toLowerCase();
        let input = '';
        if(typeof qd.userAnswer === 'string') input = qd.userAnswer;
        else if(qd.userAnswer && qd.userAnswer.dictation1) input = qd.userAnswer.dictation1;

        if(qd.type==='multiple-choice' || qd.type==='fill-in-the-blank'){
          qd.isCorrect = fmt(input) === fmt(qd.correctAnswer);
        } else if(qd.type==='translate-sentence' || qd.type==='listening-dictation'){
          qd.isCorrect = fmt(input) === fmt(qd.ko);
        }
      });
    }

    async function finishQuiz(){
      endTime = new Date();
      evaluateAnswers();

      quizContainer.classList.add('hidden');
      resultScreen.classList.remove('hidden');

      const gradables = questionsData.filter(q=>q.type!=='explanation');
      const score = gradables.filter(q=>q.isCorrect).length;
      const total = gradables.length;
      const pct = total? Math.round(score/total*100) : 0;

      $('#result-message').innerHTML =
        `<strong class="text-2xl">${studentName}, ton score est de ${score} / ${total}</strong><br>${getGradingMessage(pct,'fr')}`;

      if(pct===100) confetti({ particleCount:200, spread:90, origin:{y:.6} });

      try { await sendResults(); }
      catch(e){ /* sendResults 내부에서 처리 */ }
    }

    // ===== 오디오 재생 (Blob URL) =====
    async function playAudio(event, text, voice='woman'){
      const qd = questionsData.find(d=>d.ko===text);
      if(qd) qd.listenCount++;

      const btn = event.currentTarget;
      const original = btn.innerHTML;
      btn.disabled = true; btn.innerHTML = '로딩...';

      let url;
      try{
        const res = await fetch('/.netlify/functions/generate-audio',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ text, voice })
        });
        if(!res.ok){
          const msg = await res.text();
          throw new Error(`generate-audio ${res.status}: ${msg}`);
        }
        const { audioData, mimeType } = await res.json();
        if(!audioData) throw new Error('No audio data returned');

        const blob = base64ToBlob(audioData, mimeType || 'audio/mpeg');
        url = URL.createObjectURL(blob);

        const audio = new Audio(url);
        await audio.play();
        audio.onended = ()=>{ if(url) URL.revokeObjectURL(url); btn.disabled=false; btn.innerHTML=original; };

      } catch(err){
        console.error('Audio playback error:', err);
        alert('오디오 재생 오류가 발생했어요.\n' + String(err).slice(0,250));
        try { await sendErrorReport(err, { where:'playAudio', ko:text }); } catch(_){}
        if(url) URL.revokeObjectURL(url);
        btn.disabled=false; btn.innerHTML=original;
      }
    }

    // ===== 녹음 =====
    async function toggleRecording(){
      const recordBtn = document.getElementById('record-btn');
      const player = document.getElementById('recording-player');

      if(typeof MediaRecorder === 'undefined'){
        alert('이 브라우저는 녹음을 지원하지 않아요. (iOS Safari는 최신 버전 필요)');
        return;
      }

      if(mediaRecorder && mediaRecorder.state==='recording'){
        mediaRecorder.stop();
        recordBtn.classList.remove('recording');
        recordBtn.textContent = 'Enregistrer / 녹음하기';
        return;
      }

      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        audioChunks = [];
        const startedAt = Date.now();

        mediaRecorder = new MediaRecorder(stream, { mimeType:'audio/webm' });
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = ()=>{
          const duration = Math.round((Date.now()-startedAt)/1000);
          const blob = new Blob(audioChunks, { type:'audio/webm' });
          const url = URL.createObjectURL(blob);
          player.src = url; player.hidden = false;

          const reader = new FileReader();
          reader.onloadend = ()=>{
            const base64 = (reader.result||'').split(',')[1] || '';
            const filename = `q${currentQuestionIndex+1}_${Date.now()}.webm`;
            questionsData[currentQuestionIndex].recording = {
              base64, filename, mimeType:'audio/webm', duration
            };
          };
          reader.readAsDataURL(blob);

          stream.getTracks().forEach(t=>t.stop());
        };

        mediaRecorder.start();
        recordBtn.classList.add('recording');
        recordBtn.textContent = 'Arrêter / 녹음 중지';

      } catch(err){
        console.error('Error recording:', err);
        alert('마이크 권한이 필요합니다. (HTTPS 환경) / Autorisez le micro.');
        try { await sendErrorReport(err, { where:'toggleRecording' }); } catch(_){}
      }
    }

    // ===== 결과 전송 =====
    async function sendResults(){
      if(resultsSent) return; // 중복 방지
      resultsSent = true;

      const totalTimeSeconds = Math.round((endTime - startTime)/1000);
      const qs = JSON.parse(JSON.stringify(questionsData));

      // userAnswer를 문자열로 정규화 + recording 키 보정
      qs.forEach(q=>{
        if(typeof q.userAnswer === 'object' && q.userAnswer !== null){
          q.userAnswer = Object.values(q.userAnswer).filter(Boolean).join(' / ');
        } else {
          q.userAnswer = (q.userAnswer||'')+'';
        }
        if(!q.recording) q.recording = {};
        q.recording = {
          base64: q.recording.base64 || '',
          filename: q.recording.filename || `rec_q${q.number||'X'}.webm`,
          mimeType: q.recording.mimeType || 'audio/webm',
          duration: q.recording.duration || 0
        };
      });

      const payload = {
        studentName,
        startTime: startTime.toISOString(),
        endTime: endTime.toISOString(),
        totalTimeSeconds,
        questions: qs
      };

      try{
        const res = await fetch('/.netlify/functions/send-results',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        if(!res.ok){
          const msg = await res.text();
          throw new Error(`send-results ${res.status}: ${msg}`);
        }
        console.log('Results sent successfully!');
      } catch(err){
        console.error('Error sending results:', err);
        alert('결과 전송 중 오류가 발생했어요.\n' + String(err).slice(0,300));
        try { await sendErrorReport(err, { where:'sendResults' }); } catch(_){}
        resultsSent = false; // 실패 시 재시도 허용
      }
    }

    // ===== 에러 리포트(학생이 본 오류를 선생님 메일로 전송) =====
    async function sendErrorReport(error, ctx={}){
      const q = questionsData[currentQuestionIndex] || {};
      const errQuestion = {
        number: q.number ?? -1,
        ko: q.ko || '',
        fr: q.fr || '',
        userAnswer: `__ERROR__ ${String(error).slice(0,500)}`,
        isCorrect: false,
        listenCount: q.listenCount || 0,
        hint1Count: q.hint1Count || 0,
        hint2Count: q.hint2Count || 0,
        recording: { base64:'', filename:'', mimeType:'', duration:0 }
      };
      const payload = {
        studentName: `${studentName || 'Élève'} (ErrorReport)`,
        startTime: (startTime||new Date()).toISOString(),
        endTime: (new Date()).toISOString(),
        totalTimeSeconds: 0,
        questions: [ errQuestion, { number:'context', ko: JSON.stringify(ctx), userAnswer:'error-context', isCorrect:false, recording:{} } ]
      };
      try{
        await fetch('/.netlify/functions/send-results',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
      } catch(_e){ /* 무시 */ }
    }

    // ===== 전역 노출 =====
    window.playAudio = playAudio;
    window.toggleRecording = toggleRecording;
    window.showHint = showHint;
  </script>
</body>
</html>
